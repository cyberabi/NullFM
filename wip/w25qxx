********************************************************************
* W25QXX - Flash Memory RBF Device Driver
*
* $Id$
*
* Edt/Rev  YYYY/MM/DD  Modified by
* Comment
* ------------------------------------------------------------------
*   0      2019/11/10  Chris Burke
* Coded as a demo for NullFM; the driver uses NullFM and SPI via nullAPI
* to access a W25Qxxx SPI flash memory that contains a single disk image.
* The image is sector-readable but only track-writable.
* Demo for Level 2 only.
*
* Portions based DC3_drvr_src example (C) Microware Systems Corporation.
*

         nam   W25QXX
         ttl   W25QXX Flash Memory RBF Device Driver

         ifp1  
         use   defsfile
         use   rbf.d
         use   nulldefs
         use   spidefs
         use   flashdefs
         endc  

DriveCnt set   1            For this demo support only one drive

******************************
*
* W25Q128 SPI Commands
*
* This device operates in SPI Mode 0 or 3, burst mode, MSB-first
* https://www.winbond.com/resource-files/w25q128jv%20revf%2003272018%20plus.pdf
*
* The device is organized into 65,536 programmable pages of 256-bytes each.
* Up to 256 bytes can be programmed at a time. Pages can be erased in groups 
* of 16 (4KB  sector  erase).
*
* The erased state is $FF, and once programmed a byte can't be reprogrammed
* (other than by clearing additional bits) unless first erased.
*

F.PGPGM  equ   $02          (A A A D...) Page program / write (a sector is 4K; a page is 256 bytes)
F.WRDS   equ   $04          Write disable
F.RSTS1  equ   $05          (d) Read status register 1 (7-0)
F.WREN   equ   $06          Write enable
F.READF  equ   $0B          (A A A 0 d...) Fast read
F.RSTS3  equ   $15          (d) Read status register 3 (23-16)
F.ERSCT  equ   $20          (A A A) Sector erase (a sector is 4K: a page is 256 bytes)
F.RSTS2  equ   $35          (d) Read status register 2 (15-8)
F.ERCHP  equ   $60          Erase entire chip
F.ENRST  equ   $66          Enable soft reset
F.EXRST  equ   $99          Execute soft reset
F.ERCH2  equ   $C7          Erase entire chip (secondary)

S1.WEL   equ   %00000010    Indicates write enabled
S1.BSY   equ   %00000001    Indicates a write in progress

S3.DRV   equ   %01100000    Hardware driver strength of output (defaults to 3)


******************************
*
* Static Storage
*
*
         org   Drvbeg
         rmb   Drvmem*DriveCnt

CURTBL   rmb   2            Ptr to current drive tbl
CURDRV   rmb   1            Drive select bit pattern
V.TMP    rmb   1            Temporary save byte
V.BUF    rmb   2            Local buffer addr
V.FREZ   rmb   1            Freeze dd. info (for one read0)

V.SPI    rmb   2            Device table entry for SPIBUS
V.HNDL   rmb   1            SPI device handle (only need one in this demo)
V.PBLK   rmb   NPB.SIZ      SPI parameter block (only need one in this demo)
size     equ   .            Total static requirement


******************************
*
* Module header
*

tylg     set   Drivr+Objct   
atrv     set   ReEnt+rev
rev      set   $00
edition  set   0

         mod   eom,name,tylg,atrv,start,size
         
name     fcs   "W25QXX"
         fcb   edition
         
busname  fcs   "SPIBUS"         
         
******************************
*
* Branch Table
*
start    lbra  Init
         lbra  Read
         lbra  Write
         lbra  GetStat
         lbra  SetStat
         lbra  Term


         pag
******************************
*
* Put Status Call
*

SetStat  ldx   PD.RGS,y     Point to parameters
         ldb   R$B,x        Get stat call
         cmpb  #SS.Reset    Restore call?
          beq  RESTOR       ..yes; do it (dummy operation)
         cmpb  #SS.WTrk     Write track call?
          lbeq WRTTRK       ..yes; do it.
         cmpb  #SS.FRZ      Freeze dd. info?
          beq  SETFRZ       Yes; ....flag it.
          
* We don't support any GetStt calls
GetStat  comb               ...NO; Error
         ldb   #E$UnkSvc    Error code
         rts

* Freeze dd. info
SETFRZ   ldb   #$FF
         stb   V.FREZ,u     Set flag
RESTOR   equ   *
         clrb
         rts


         pag
******************************
*
* Initialize The I/O Port
*
* The flash memory is on the SPI bus. To access it we link to
* the spi bus (SPIBUS device) via an I$Attach call, and then register
* a configuration that tells the SPI bus our slave select, the
* kind of clocking we need, etc.
*
* Entry: U = Global Storage
*        Y = Device Descriptor
*
* Exit:  A Modified
*        X Modified
*        Y Unchanged
*        U Unchanged
*

Init     lda   #$FF
         ldb   #DriveCnt
         stb   V.NDRV,u     Inz number of drives
         leax  DRVBEG,u     Point to first drive table
INILUP   sta   DD.TOT+2,x   Inz total number of sectors to non-zero (dummy)
         sta   V.TRAK,x     Inz current track to high track count (dummy)
         leax  DRVMEM,x     Point to next drive table
         decb
          bne  INILUP
          
         ldd   #256+6       We need a sector buffer + room for the largest SPI command
         pshs  u
         OS9   F$SRqMem
         tfr   u,x
         puls  U
          bcs  RETRN1       Error out if no mem available
         stx   V.BUF,u      Save base address for future use

         pshs  u
         leax  busname,pc   We need to attach to the SPI bus
         lda   #UPDAT.
         OS9   I$Attach
         tfr   u,x
         puls  U
          bcs  RETRN1       Error out if no SPI bus available
         stx   V.SPI,u      Save device table entry for future use
         
         pshs  y
         
         leay  V.PBLK,u     We need to declare a suitable SPI configuration; parameter block
         ldd   #(CKR.0US*256+CKA.MD0+CKA.BRST) No delays, mode 0, burst mode
         lbsr  NFInitPB     Call API function to set up parameter block
         lda   #UPDAT.+ATR.MSB
         ldb   V.PORT+1,u   Get our slave select from the dummy address
         andb  #3
         orb   #CKA.BRST    Burst mode
         std   NPB.Y,y
         
         ldb   #SPI.RDTC    Register the configuration
         stb   NPB.FUNC,y
         lbsr  NFDirect     Call API function to register configuration
         lda   NPB.HNDL,y
         puls  y
          bcs  RETRN1
         sta   V.HNDL,u     Save "handle" for our SPI configuration
         clrb
RETRN1   rts


         pag
******************************
*
* Write Sector Command
*
* This is a flash device, and we can only "clear" bits
* in it during a write. A format "sets" all bits in a
* given track.
*
* The main way to enforce this is to pre-read the sector
* to make sure it is all $FF; if not, return a write error.
* This makes writes expensive but they are meant to happen
* only once (e.g. when backup up another disk here)
*
* Because we allocate two full flash "sectors" per track
* regardless of actual track size, we have to translate
* the provided LSN to get a correct flash address.
*
* Entry: B = Msb Of Logical Sector Number
*        X = Lsb's Of Logical Sector Number
*        Y = Path Descriptor
*        U = Global Storage
*
*        PD.BUF,Y = Sector buffer
*
* Error:
*   Carry Set
*   B = Error Code
*

Write    bsr   SELECT       Select drive
          bcs  WRERR9
          
* FIXME: Translate the LSN
* FIXME: Pre-read the sector and check for $FF
* FIXME: Write the sector from caller's buffer

         comb
         ldb   #E$WP        Error: write protected
WRERR9   rts


******************************
*
* Write Full Track (SS.WTrk)
*
* For this device, we always allocate 32 pages (two sectors, 8K)
* to a track regardless of how much the device actually uses.
*
* Note that this will fail if a device descriptor declares more
* than 32 spt (which we could check at the Init call but don't).
*
* The caller's track buffer is ignored; we just erase the "track".
*
* Entry: X = PD.RGS
*        Y = Path Descriptor
*        U = Global Storage
*
*        R$X = Address of track buffer.*        R$U = Track number (LS 8 bits)
*        R$Y = Side number (LS bit)
*

WRTTRK   bsr   SELECT       Select drive
          bcs  WRERR9

         lda   R$U+1,x      Track number
         ldb   R$Y+1,x      Side/density info
         ldx   Curtbl,u     Point to drive table
         stb   DD.Fmt,x     Update media format byte
         
* Write-enable the flash
         asla
         pshs  a            (two flash "sectors" per logical track)
         ldb   #F.WREN      Write-enable the device
         bsr   CMD1B        (execute one-byte command)
          bcs  WRERR9
         
* Erase this part of the flash first
         bsr   SCT2ADR      Get starting address of 1st flash sector in this track
         ldb   #F.ERSCT     Erase Sector command
         bsr   CMD4B
         puls  a
          bcs  WRERR9
          
         inca
         bsr   SCT2ADR      Get starting address of 2nd flash sector in this track
         ldb   #F.ERSCT     Erase Sector command
         bsr   CMD4B
          bcs  WRERR9
         
         rts
         
         
*
* Convert a flash sector number in A, to a flash address in A:X.
* A flash sector is 16 pages, a page is 256 bytes
*
SCT2ADR  clr   ,-s
         ldb   #16
         mul
         pshs  d
         puls  a,x,pc

*
* Convert an LSN in B:X and sectors-per-track in A to a physical track number
* in X and a physical page within the track in B.
* A physical track is always 32 pages for this driver (some can be unused);
* the sectors-per-track will be in the range 1..32.
*
* For this demo we just use an ugly subtraction loop to divide
*
LSN2TRK  clr   ,-s
         clr   ,-s
         clr   ,-s
         pshs  b,x
         clrb
         exg   a,b
         pshs  d
         pshs  a           Now have 24-bit divisor at 0,s; 24-bit dividend at 3,s; 24-bit quotient at 6,s
         
DIVLP    ldd   3+1,s
         subd  0+1,s
         std   3+1,s
         lda   3+0,s
         sbca  #0
          bcc  DIVOK
          
* This subtraction failed; correct remainder and exit
         ldb   3+1+1,s
         addd  0+1,s        Correct remainder (sector) is in D (B actually); correct track is at 6+1,s
         leas  6+1,s
         puls  x,pc

* Subtraction succeeded; increment quotient
DIVOK    sta   3+0,s
         ldd   6+1,s
         addd  #1
         std   6+1,s
         lda   6+0,s
         adca  #0
         sta   6+0,s
         bra   DIVLP
         
         
 pag
******************************
*
* Read Sector Command
*
* Because we allocate two full flash "sectors" per track
* regardless of actual track size, we have to translate
* the provided LSN to get a correct flash address.
*
* Entry: B = Msb Of Logical Sector Number
*        X = Lsb's Of Logical Sector Number
*        Y = Path Descriptor
*        U = Global Storage
*
*        PD.BUF,Y = Sector buffer
*
* Exit:  256 Bytes Of Data Returned In Buffer
*
* Error:
*   Carry Set
*   B = Error Code
*
*
*
* Error: Cc=Set, B=Error Code
*
Read     bsr   SELECT       Select drive
          bcs  RDERR9
          
* FIXME: Translate the LSN
* FIXME: Read the sector

         comb
         ldb   #E$WP        Error: write protected
RDERR9   rts
 

         pag
******************************
*
* Select Drive
*
* Entry: U = Pointer To Global Storage
*        Y = Pointer To Path Descriptor
*
* Exit:  Curtbl,u=Current Drive Tbl
*        Curdrv,u=Drive Number
*
SELECT   lda   PD.DRV,y     Get drive number
         cmpa  V.NDRV,u     Drive num ok?
          bhs  ERUNIT
          
         pshs  b,x
         sta   CURDRV,u
         leax  DRVBEG,u     Table beginning
         ldb   #DRVMEM
         mul                OFFSET For this drive
         leax  d,x
         stx   CURTBL,u     Current table ptr
         clr   V.SIDE,u     Default to side zero (used by PHYSIC)
         puls  b,x,pc


ERUNIT   comb
         ldb   #E$UNIT      Error: illegal unit (drive)
         rts
         
         
 pag
**************************************************************
*
* Convert Logical Sector Number
* To Physical Track And Sector
*
*  Input:  B = Msb Of Logical Sector Number
*          X = Lsb'S Of Logical Sector Number
*          U = Global storage
*
*          V.SIDE,U = 0 (cleared by SELECT)
*
*  Output: A = Physical Track Number
*          Sector Reg = Physical Sector Number
*  Error:  Carry Set & B = Error Code
*
PHYSIC   tstb               CHECK Sector bounds
          bne  PHYERR       msb must be zero
          
         tfr   x,d          Logical sector (os-9)
         cmpd  #0           Logical sector zero?
          beq  PHYSC7       ..yes; skip conversion.
          
         ldx   CURTBL,u
         cmpd  DD.TOT+1,x   Too high sector number?
          bhs  PHYERR       ..yes; sorry
          
         stb   V.TMP,u      Save (b)
         clrb
         pshs  b            Will be track number
         ldb   DD.FMT,x
         lsrb               SHIFT Side bit to carry
         ldb   V.TMP,u      Restore (b)
          bcs  PHYSC4       Bra if double sided
          
* Compute track (single-sided)
         dec   0,s          (single-sided starts at -1)
PHYSC2   inc   0,s
         subb  DD.TKS,x     Subtract one track worth of sectors
         sbca  #0
          bcc  PHYSC2       Repeat until less than 1 track size
         bra   PHYSC5
         
* Compute track (double-sided) (enter at PHYSC4)
* Even-numbered tracks are on side 0, odd-numbered tracks
* are on side 1
PHYSC3   com   V.SIDE,u     Switch sides
          bne  PHYSC4       Skip track inc if side 1
          
         inc   0,s
         
PHYSC4   subb  DD.TKS,x
         sbca  #0
          bcc  PHYSC3       Repeat until less than 1 trk
          
PHYSC5   addb  DD.TKS,x     Add back for sector number
         puls  a            Desired track.
         
PHYSC7   stb   [V.SECR,u]   Put sector (b) in sector reg
         clrb
RETRN2   rts


PHYERR   comb
         ldb   #E$SECT      Error: bad sector number
         rts

 
 pag
****************************************************************
*
* Read Logical Sector Zero
*
*
*
READ0 lbsr RDDSK3 Read sector
 bcs DELAY4
 ldx PD.BUF,y
 pshs X,y
 tst V.Frez,u Skip copy of dd. info?
 bne Read05 Yes; ....make quick exit
 ldy CURTBL,u
 ldb #DD.SIZ-1
READ01 lda b,x
 sta B,y
 decb
 bpl READ01
 lda DD.FMT,y
 ldy 2,S Restore (y)
 ldb Pd.Dns,y Get drive capabilities
 bita #%00000010 Media dden?
 bne TYPERR ..yes; report error.
 bitb #%00000001 Drive dden?
 bne Typerr Yes; ....no can do.
 bita #%00000100 Media dbl track dens?
 beq Read03 No; ....all's well
 bitb #%00000010 Drive dbl track dens?
 beq Typerr No; .....incompatible media
Read03 bita #%00000001 Dbl sided?
 beq READ05 ...no; we can handle it.
 lda PD.SID,y
 suba #2
 bcs TYPERR
READ05 clrb
 puls X,y,pc


TYPERR comb
 ldb #E$BTYP
 puls X,y,pc
 
 
 pag
**************************************
*
* Terminate use of the disk
*
*
*    Return Local memory to the system
*
*

TERMNT ldu V.BUF,u Point to memory for return
 ldd #256
 OS9 F$SRtMem Return local buffer to free mem
 clrb
 rts


 emod

eom equ *

 end
